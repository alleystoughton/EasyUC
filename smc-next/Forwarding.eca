(* Forward.ec *)

(* Ideal Forwarding Functionality *)

(* This functionality implements authenticated forwarding (Fauth),
   where the adversary is asked to approve the forwarding of a value,
   but may not corrupt either the value or its destination/source *)

prover quorum=2 ["Alt-Ergo" "Z3"].

require import AllCore List UCCore.

require Forwarding_Code.  (* code for ideal functionality *)
clone import Forwarding_Code as FC.

(* termination metric and proof *)

op term_metric_max : int = 2.

(* FIXME when better glob type

   print glob Forw:
   1: Forw.st : fw_state
   2: Forw.adv : addr
   3: Forw.self : addr *)

op term_metric (g : glob Forw) : int =
     match g.`1 with
     | _FwStateInit       => 2
     | _FwStateWait _ _ _ => 1
     | _FwStateFinal      => 0
     end.

lemma ge0_term_metric (g : glob Forw) : 0 <= term_metric g.
proof.
rewrite /term_metric.
case g => x1 x2 x3 /= /#.
qed.

lemma init :
  equiv
  [Forw.init ~ Forw.init :
   ={self_, adv_} ==> ={res, glob Forw}].
proof.
proc; auto.
qed.

lemma term_init :
  equiv
  [Forw.init ~ Forw.init :
   ={self_, adv_} ==>
   ={res, glob Forw} /\
   term_metric (glob Forw){1} = term_metric_max].
proof.
proc; auto.
qed.

lemma term_invoke (n : int) :
  equiv
  [Forw.invoke ~ Forw.invoke :
   ={m, glob Forw} /\
   term_metric (glob Forw){1} = n ==>
   ={res, glob Forw} /\
   (res{1} = None \/ term_metric (glob Forw){1} < n)].
proof.
proc; sp 1 1.
if => //.
inline Forw.parties.
sp 2 2.
match => //.
match => //.
auto.
move => x x'.
if; first move => /> &2 -> /= -> />.
auto; first move => /> &2 -> /= -> />.
auto.
move => pt1 pt2 u pt1' pt2' u'.
match => //.
auto.
move => x x'.
if => //.
auto.
auto.
auto.
qed.

(* phoare lemmas for invoke *)

pred forw_invoke_init_fw_req (self adv : addr, m : msg) =
  is_valid FwDir.D.epdp_fw_req_msg m /\
  (oget (FwDir.D.epdp_fw_req_msg.`dec m)).`FwDir.D.fw_req__func = self /\
  envport self adv (oget (FwDir.D.dec_fw_req m)).`FwDir.D.fw_req_pt1 /\
  envport self adv (oget (FwDir.D.dec_fw_req m)).`FwDir.D.fw_req_pt2.


lemma Forw_invoke_init_fw_req (m' : msg) :
  phoare
  [Forw.invoke :
   m' = m /\ Forw._st = _FwStateInit /\
   forw_invoke_init_fw_req Forw._self Forw._adv m ==>
   let fwr = oget (FwDir.D.dec_fw_req m') in
   res =
   Some
   (FwAdv.enc_fw_obs
    {|FwAdv.fw_obs__func = fwr.`FwDir.D.fw_req__func;
      FwAdv.fw_obs__adv  = Forw._adv;
      FwAdv.fw_obs_pt1   = fwr.`FwDir.D.fw_req_pt1;
      FwAdv.fw_obs_pt2   = fwr.`FwDir.D.fw_req_pt2;
      FwAdv.fw_obs_u     = fwr.`FwDir.D.fw_req_u|}) /\
   Forw._st =
     _FwStateWait fwr.`FwDir.D.fw_req_pt1 fwr.`FwDir.D.fw_req_pt2
     fwr.`FwDir.D.fw_req_u /\
   envport Forw._self Forw._adv fwr.`FwDir.D.fw_req_pt2] = 1%r.
proof.
proc.
sp 1.
rcondt 1; first auto; smt(FwDir.D.eq_of_valid_fw_req).
inline Forw.parties.
sp 2.
match _FwStateInit 1; first auto; smt().
match Some 1.
auto; smt(some_oget).
rcondt 1; first auto; progress; smt().
auto.
auto; smt(oget_some).
qed.

lemma Forw_invoke_init_bad :
  phoare
  [Forw.invoke :
   Forw._st = _FwStateInit /\
   ! forw_invoke_init_fw_req Forw._self Forw._adv m ==>
   res = None /\ Forw._st = _FwStateInit] = 1%r.
proof.
proc.
sp 1.
if.
inline Forw.parties.
sp 2.
match _FwStateInit 1; first auto; smt().
case (FwDir.D.epdp_fw_req_msg.`dec _m = None).
match None 1; first auto.
auto.
match Some 1; first auto; smt().
rcondf 1; first auto; smt(FwDir.D.eq_of_valid_fw_req).
auto.
auto.
qed.

pred forw_invoke_wait_fw_ok (self adv : addr, pt2 : port, m : msg) =
  is_valid FwAdv.epdp_fw_ok_msg m /\
  (oget (FwAdv.epdp_fw_ok_msg.`dec m)).`FwAdv.fw_ok__func = self /\
  (oget (FwAdv.epdp_fw_ok_msg.`dec m)).`FwAdv.fw_ok__adv = adv /\
  (oget (FwAdv.epdp_fw_ok_msg.`dec m)).`FwAdv.fw_ok__func = self /\
  envport self adv pt2.

lemma Forw_invoke_wait_fw_ok (st' : _fw_state, m' : msg) :
  phoare
  [Forw.invoke :
   st' = Forw._st /\ m' = m /\ get_as__FwStateWait Forw._st <> None /\
   forw_invoke_wait_fw_ok Forw._self Forw._adv
   (oget (get_as__FwStateWait Forw._st)).`2 m ==>
   let wait = oget (get_as__FwStateWait st') in
   res =
   Some
   (FwDir.D.epdp_fw_rsp_msg.`enc
    {|FwDir.D.fw_rsp__func = Forw._self; FwDir.D.fw_rsp_pt1 = wait.`1;
      FwDir.D.fw_rsp_pt2 = wait.`2; FwDir.D.fw_rsp_u = wait.`3|}) /\
   Forw._st = _FwStateFinal] = 1%r.
proof.
proc.
sp 1.
rcondt 1; first auto; smt(FwAdv.eq_of_valid_fw_ok).
inline Forw.parties.
sp 2.
match _FwStateWait 1.
auto => |> &hr.
rewrite /get_as__FwStateWait.
case (Forw._st{hr}) => // pt1 pt2 u /= _.
by exists pt1 pt2 u.
match Some 1; first auto => |> &hr.
rewrite /get_as__FwStateWait /= /#.
rcondt 1; first auto => |> &hr _ _.
by rewrite /forw_invoke_wait_fw_ok /get_as__FwStateWait.
auto; by rewrite /get_as__FwStateWait.
qed.

lemma Forw_invoke_wait_bad (st' : _fw_state) :
  phoare
  [Forw.invoke :
   st' = Forw._st /\ get_as__FwStateWait Forw._st <> None /\
   ! forw_invoke_wait_fw_ok Forw._self Forw._adv
     (oget (get_as__FwStateWait Forw._st)).`2 m ==>
   res = None /\ Forw._st = st'] = 1%r.
proof.
proc.
sp 1.
if.
inline Forw.parties.
sp 2.
match _FwStateWait 1.
auto => /> &hr.
rewrite /get_as__FwStateWait.
case (Forw._st{hr}) => // pt1 pt2 u /= _ _.
by exists pt1 pt2 u.
case (FwAdv.epdp_fw_ok_msg.`dec _m = None).
match None 1; first auto.
auto.
match Some 1.
auto; progress.
exists (oget (FwAdv.epdp_fw_ok_msg.`dec m{hr})).
by apply some_oget.
if.
exfalso; smt(oget_some FwAdv.eq_of_valid_fw_ok).
auto.
auto.
qed.

lemma Forw_invoke_final :
  phoare
  [Forw.invoke :
   Forw._st = _FwStateFinal ==>
   res = None /\ Forw._st = _FwStateFinal] = 1%r.
proof.
proc.
sp 1.
if.
inline Forw.parties.
sp 2.
match _FwStateFinal 1; first auto; smt().
auto.
auto.
qed.
